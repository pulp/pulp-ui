# .gitlab-ci.yml — Stable with bulletproof report + Pages + WikiJS (fixed before_script)

include:
  - template: Jobs/SAST.gitlab-ci.yml
  - template: Jobs/Dependency-Scanning.gitlab-ci.yml
  - template: Jobs/Secret-Detection.gitlab-ci.yml

variables:
  GITLAB_ADVANCED_SAST_ENABLED: "true"
  SAST_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static,cypress,playwright-report,**/*.min.js,**/*.map"
  DS_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"
  SECRET_DETECTION_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - when: never

semgrep-sast:
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - changes:
        - "**/*.js"
        - "**/*.jsx"
        - "**/*.ts"
        - "**/*.tsx"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

gemnasium-dependency_scanning:
  artifacts:
    when: always
    paths:
      - gl-dependency-scanning-report.json
      - gl-sbom-*.cdx.json
  variables:
    DS_LOCK_FILE_PATHS: "yarn.lock,package-lock.json,pnpm-lock.yaml,**/yarn.lock,**/package-lock.json,**/pnpm-lock.yaml"
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - changes:
        - yarn.lock
        - package-lock.json
        - pnpm-lock.yaml
        - "**/yarn.lock"
        - "**/package-lock.json"
        - "**/pnpm-lock.yaml"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
      exists:
        - yarn.lock
        - package-lock.json
        - pnpm-lock.yaml
        - "**/yarn.lock"
        - "**/package-lock.json"
        - "**/pnpm-lock.yaml"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

secret_detection:
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

stages:
  - test
  - build
  - deploy
  - security
  - report

generate_security_report:
  stage: report
  image: alpine:3.19
  needs:
    - job: semgrep-sast
      artifacts: true
    - job: gemnasium-dependency_scanning
      artifacts: true
    - job: secret_detection
      artifacts: true
  before_script:
    - apk add --no-cache jq
  script: |
    set -e
    mkdir -p out

    md=out/security-report.md
    html=out/security-report.html

    echo "== Debug: downloaded security artifacts =="
    find . -maxdepth 3 -type f \( -name "gl-*-report.json" -o -name "gl-sbom-*.cdx.json" \) | sort || true

    SAST_JSON="${SAST_JSON:-gl-sast-report.json}"
    DS_JSON="${DS_JSON:-gl-dependency-scanning-report.json}"
    SECRETS_JSON="${SECRETS_JSON:-gl-secret-detection-report.json}"

    # locate DS report if not at root
    if [ ! -f "$DS_JSON" ]; then
      DS_JSON_FOUND=$(find . -type f -name "gl-dependency-scanning-report.json" | head -n1 || true)
      if [ -n "$DS_JSON_FOUND" ]; then
        echo "Using DS report at: $DS_JSON_FOUND"
        DS_JSON="$DS_JSON_FOUND"
      else
        echo "WARNING: Dependency Scanning report not found. Was the job skipped?"
      fi
    fi

    {
      echo "# Security Report"
      echo
      echo "_Generated on $(date -u +"%Y-%m-%d %H:%M:%SZ")_"
      echo
    } > "$md"

    summarize() {
      title="$1"; file="$2"
      {
        echo "## $title"
        if [ -f "$file" ]; then
          count=$(jq '.vulnerabilities | length' "$file" 2>/dev/null || echo 0)
          echo
          echo "Findings: $count"
          echo
          if [ "$count" -gt 0 ]; then
            echo "| Severity | Category | Name | File | Lines |"
            echo "|---|---|---|---|---|"
            jq -r '
              def esc: tostring | gsub("\\|"; "&#124;");
              (.vulnerabilities // [])[] as $v
              | [
                  ($v.severity // "unknown") | esc,
                  ($v.category // "unknown") | esc,
                  ($v.name // "n/a") | esc,
                  ($v.location.file // "n/a") | esc,
                  (
                    ( ($v.location.start_line // "")|tostring )
                    + (if $v.location.end_line then "-" + (($v.location.end_line)|tostring) else "" end)
                  ) | esc
                ]
              | @tsv
            ' "$file" 2>/dev/null \
            | awk -F'\t' '{printf("| %s | %s | %s | %s | %s |\n",$1,$2,$3,$4,$5)}' || {
              echo "_(Failed to render table rows)_"
            }
          else
            echo "_No vulnerabilities detected._"
          fi
        else
          echo
          echo "_Report not found (job may have been skipped)._"
        fi
        echo
      } >> "$md" || true
    }

    summarize "SAST" "$SAST_JSON"
    summarize "Dependency Scanning" "$DS_JSON"
    summarize "Secret Detection" "$SECRETS_JSON"

    {
      echo "<!doctype html><meta charset='utf-8'><title>Security Report</title>"
      echo "<style>body{font-family:sans-serif;max-width:980px;margin:32px auto;padding:0 16px} table{border-collapse:collapse;width:100%} th,td{border:1px solid #ddd;padding:8px} th{background:#f5f5f5;text-align:left}</style>"
      echo "<article>"
      awk '
        /^# /{print "<h1>"substr($0,3)"</h1>";next}
        /^## /{print "<h2>"substr($0,4)"</h2>";next}
        /^\|/{
          if (!intable){print "<table>"; intable=1}
          gsub(/^\||\|$/,""); n=split($0, a, /\|/)
          if (!header_done){ print "<tr>"; for(i=1;i<=n;i++) print "<th>"a[i]"</th>"; print "</tr>"; header_done=1; next }
          print "<tr>"; for(i=1;i<=n;i++) print "<td>"a[i]"</td>"; print "</tr>"; next
        }
        { if (intable){print "</table>"; intable=0; header_done=0} print "<p>"$0"</p>"}
        END{ if (intable){print "</table>"} }
      ' "$md" || true
      echo "</article>"
    } > "$html" || true

    if [ ! -s "$html" ]; then
      echo "HTML was empty or missing; writing fallback."
      {
        echo "<!doctype html><meta charset='utf-8'><title>Security Report</title><pre>"
        sed 's/&/\&amp;/g; s/</\&lt;/g' "$md"
        echo "</pre>"
      } > "$html"
    fi

  artifacts:
    name: "security-report"
    when: always
    expire_in: 30 days
    paths:
      - out/security-report.md
      - out/security-report.html
    expose_as: "Security Report"
  rules:
    - when: always

pages:
  stage: report
  needs:
    - job: generate_security_report
      artifacts: true
  script:
    - mkdir -p public
    - cp out/security-report.html public/index.html
  artifacts:
    paths:
      - public
  rules:
    - when: always

publish_wikijs:
  stage: report
  image: alpine:3.19
  needs:
    - job: generate_security_report
      artifacts: true
  variables:
    WIKI_TITLE: "Pulp UI Security Report (Latest)"
    WIKI_DESCRIPTION: "Security report for pulp-ui (auto-generated)"
    WIKI_TAGS: "security,report,pulp-ui"
    WIKI_LOCALE: "en"
  before_script:
    - set -euo pipefail
    - apk add --no-cache curl jq ca-certificates coreutils
    - test -f out/security-report.md || { echo "security-report.md missing"; ls -la out || true; exit 1; }
    - if [ -z "${WIKI_URL:-}" ]; then echo "WIKI_URL required"; exit 1; fi
    - if [ -z "${WIKI_TOKEN:-}" ]; then echo "WIKI_TOKEN required"; exit 1; fi
  script: |
    set -euo pipefail
    PROJECT_SLUG="${CI_PROJECT_PATH_SLUG:-${CI_PROJECT_NAME:-project}}"
    TARGET_PATH="${WIKI_PATH:-security/${PROJECT_SLUG}/latest}"
    MD_RAW="$(cat out/security-report.md)"
    TAGS_JSON=$(printf '%s' "${WIKI_TAGS:-}" | jq -Rs 'split(",") | map(gsub("^[[:space:]]+|[[:space:]]+$";"")) | map(select(length>0))')

    call_gql () {
      curl -sS -H "Authorization: Bearer ${WIKI_TOKEN}" -H "Content-Type: application/json" \
        --data "$1" "${WIKI_URL%/}/graphql"
    }

    # 1) Lookup page
    GET=$(jq -cn --arg path "$TARGET_PATH" --arg locale "$WIKI_LOCALE" '
      {query:"query($path:String!,$locale:String!){ pages { singleByPath(path:$path, locale:$locale){ id path title isPublished editorKey } } }",
       variables:{path:$path, locale:$locale}}')
    RES=$(call_gql "$GET")
    ID=$(echo "$RES" | jq -r '.data.pages.singleByPath.id // empty')
    PUBLISHED=$(echo "$RES" | jq -r '.data.pages.singleByPath.isPublished // false')
    EDITOR=$(echo "$RES" | jq -r '.data.pages.singleByPath.editorKey // empty')

    if [ -n "$ID" ]; then
      # 2) Update existing page: enforce markdown + published
      UP=$(jq -cn --argjson id "$ID" --arg content "$MD_RAW" '
        {query:"mutation($id:Int!,$content:String!){ pages { update(id:$id, content:$content, isPublished:true, editor:\"markdown\"){ responseResult{ succeeded message } } } }",
         variables:{id:$id, content:$content}}')
      call_gql "$UP" >/dev/null || true
    else
      # 3) Create page with markdown + published
      CR=$(jq -cn \
        --arg path "$TARGET_PATH" --arg title "${WIKI_TITLE}" --arg locale "$WIKI_LOCALE" \
        --arg desc "${WIKI_DESCRIPTION}" --arg content "$MD_RAW" --argjson tags "$TAGS_JSON" '
        {query:"mutation($path:String!,$title:String!,$locale:String!,$description:String!,$tags:[String]!, $content:String!){ pages { create(path:$path, title:$title, locale:$locale, editor:\"markdown\", isPublished:true, isPrivate:false, description:$description, tags:$tags, content:$content){ responseResult{ succeeded message } page{ id path } } } }",
         variables:{path:$path, title:$title, locale:$locale, description:$desc, tags:$tags, content:$content}}')
      call_gql "$CR" >/dev/null
    fi
  
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - when: never




# # .gitlab-ci.yml — Stable rollback: working scans + report + WikiJS publish with proper Markdown

# include:
#   - template: Jobs/SAST.gitlab-ci.yml
#   - template: Jobs/Dependency-Scanning.gitlab-ci.yml
#   - template: Jobs/Secret-Detection.gitlab-ci.yml

# variables:
#   # Set to "false" if you don't have Ultimate
#   GITLAB_ADVANCED_SAST_ENABLED: "true"

#   # Speed up scans by skipping noise
#   SAST_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static,cypress,playwright-report,**/*.min.js,**/*.map"
#   DS_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"
#   SECRET_DETECTION_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"

# # Only create pipelines for: MRs, default branch pushes, or schedules
# workflow:
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
#     - if: $CI_PIPELINE_SOURCE == "schedule"
#     - when: never

# # SAST (Semgrep or Advanced SAST)
# semgrep-sast:
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "schedule"
#       when: on_success
#     - changes:
#         - "**/*.js"
#         - "**/*.jsx"
#         - "**/*.ts"
#         - "**/*.tsx"
#       when: on_success
#     - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
#       when: on_success
#     - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#       when: on_success
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
#       when: on_success
#     - when: never

# # Dependency Scanning (Gemnasium)
# gemnasium-dependency_scanning:
#   variables:
#     DS_LOCK_FILE_PATHS: "yarn.lock,package-lock.json,pnpm-lock.yaml,**/yarn.lock,**/package-lock.json,**/pnpm-lock.yaml"
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "schedule"
#       when: on_success
#     - changes:
#         - yarn.lock
#         - package-lock.json
#         - pnpm-lock.yaml
#         - "**/yarn.lock"
#         - "**/package-lock.json"
#         - "**/pnpm-lock.yaml"
#       when: on_success
#     - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
#       exists:
#         - yarn.lock
#         - package-lock.json
#         - pnpm-lock.yaml
#         - "**/yarn.lock"
#         - "**/package-lock.json"
#         - "**/pnpm-lock.yaml"
#       when: on_success
#     - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#       when: on_success
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
#       when: on_success
#     - when: never

# # Secret Detection (Gitleaks ruleset)
# secret_detection:
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "schedule"
#       when: on_success
#     - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#       when: on_success
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
#       when: on_success
#     - when: never

# stages:
#   - test
#   - build
#   - deploy
#   - security
#   - report

# generate_security_report:
#   stage: report
#   image: alpine:3.19
#   needs:
#     - job: semgrep-sast
#       artifacts: true
#     - job: gemnasium-dependency_scanning
#       artifacts: true
#     - job: secret_detection
#       artifacts: true
#   before_script:
#     - apk add --no-cache jq
#   script: |
#     set -e
#     mkdir -p out

#     md=out/security-report.md
#     html=out/security-report.html
#     echo "== Debug: downloaded security artifacts =="
#     find . -maxdepth 3 -type f \( -name "gl-*-report.json" -o -name "gl-sbom-*.cdx.json" \) | sort || true

#     SAST_JSON="${SAST_JSON:-gl-sast-report.json}"
#     DS_JSON="${DS_JSON:-gl-dependency-scanning-report.json}"
#     SECRETS_JSON="${SECRETS_JSON:-gl-secret-detection-report.json}"

#     # locate DS report if not at root
#     if [ ! -f "$DS_JSON" ]; then
#       DS_JSON_FOUND=$(find . -type f -name "gl-dependency-scanning-report.json" | head -n1 || true)
#       if [ -n "$DS_JSON_FOUND" ]; then
#         echo "Using DS report at: $DS_JSON_FOUND"
#         DS_JSON="$DS_JSON_FOUND"
#       else
#         echo "WARNING: Dependency Scanning report not found. Was the job skipped?"
#       fi
#     fi

#     echo "# Security Report" > "$md"
#     echo "" >> "$md"
#     echo "_Generated on $(date -u +"%Y-%m-%d %H:%M:%SZ")_" >> "$md"
#     echo "" >> "$md"

#     summarize() {
#       title="$1"; file="$2"
#       echo "## $title" >> "$md"
#       if [ -f "$file" ]; then
#         count=$(jq '.vulnerabilities | length' "$file" 2>/dev/null || echo 0)
#         echo "" >> "$md"
#         echo "Findings: $count" >> "$md"
#         echo "" >> "$md"
#         if [ "$count" -gt 0 ]; then
#           echo "| Severity | Category | Name | File | Lines |" >> "$md"
#           echo "|---|---|---|---|---|" >> "$md"
#           jq -r '
#             (.vulnerabilities // [])[]
#             | [
#                 (.severity // "unknown"),
#                 (.category // "unknown"),
#                 (.name // "n/a"),
#                 (.location.file // "n/a"),
#                 (
#                   ( (.location.start_line // "")|tostring )
#                   + (if .location.end_line then "-" + ((.location.end_line)|tostring) else "" end)
#                 )
#               ]
#             | @tsv
#           ' "$file" | awk -F'	' '{printf("| %s | %s | %s | %s | %s |",$1,$2,$3,$4,$5)}' >> "$md"
#         else
#           echo "_No vulnerabilities detected._" >> "$md"
#         fi
#       else
#         echo "" >> "$md"
#         echo "_Report not found (job may have been skipped)._" >> "$md"
#       fi
#       echo "" >> "$md"
#     }

#     summarize "SAST" "$SAST_JSON"
#     summarize "Dependency Scanning" "$DS_JSON"
#     summarize "Secret Detection" "$SECRETS_JSON"

#     {
#       echo "<!doctype html><meta charset='utf-8'><title>Security Report</title>"
#       echo "<style>body{font-family:sans-serif;max-width:980px;margin:32px auto;padding:0 16px} table{border-collapse:collapse;width:100%} th,td{border:1px solid #ddd;padding:8px} th{background:#f5f5f5;text-align:left}</style>"
#       echo "<article>"
#       awk '
#         /^# /{print "<h1>"substr($0,3)"</h1>";next}
#         /^## /{print "<h2>"substr($0,4)"</h2>";next}
#         /^\|/{
#           if (!intable){print "<table>"; intable=1}
#           gsub(/^\||\|$/,""); n=split($0, a, /\|/)
#           if (!header_done){ print "<tr>"; for(i=1;i<=n;i++) print "<th>"a[i]"</th>"; print "</tr>"; header_done=1; next }
#           print "<tr>"; for(i=1;i<=n;i++) print "<td>"a[i]"</td>"; print "</tr>"; next
#         }
#         { if (intable){print "</table>"; intable=0; header_done=0} print "<p>"$0"</p>"}
#         END{ if (intable){print "</table>"} }
#       ' "$md"
#       echo "</article>"
#     } > "$html"

#   artifacts:
#     name: "security-report"
#     when: always
#     expire_in: 30 days
#     paths:
#       - out/security-report.md
#       - out/security-report.html
#     expose_as: "Security Report"
#   rules:
#     - when: always

# # Publish the HTML report on GitLab Pages
# pages:
#   stage: report
#   needs:
#     - job: generate_security_report
#       artifacts: true
#   script:
#     - mkdir -p public
#     - cp out/security-report.html public/index.html
#   artifacts:
#     paths:
#       - public
#   rules:
#     - when: always

# # Publish to WikiJS with RAW Markdown (no escaped \n)
# publish_wikijs:
#   stage: report
#   image: alpine:3.19
#   needs:
#     - job: generate_security_report
#       artifacts: true
#   variables:
#     WIKI_TITLE: "Pulp UI Security Report (Latest)"
#     WIKI_DESCRIPTION: "Security report for pulp-ui (auto-generated)"
#     WIKI_TAGS: "security,report,pulp-ui"
#     WIKI_LOCALE: "en"   # set your default locale here
#     # Set these in CI/CD → Variables:
#     # WIKI_URL, WIKI_TOKEN, (optional) WIKI_PATH
#   before_script:
#     - set -eux
#     - apk add --no-cache curl jq ca-certificates coreutils
#     - test -f out/security-report.md
#     - test -n "${WIKI_URL:-}"   || { echo "WIKI_URL required"; exit 1; }
#     - test -n "${WIKI_TOKEN:-}" || { echo "WIKI_TOKEN required"; exit 1; }
#   script: |
#     set -euo pipefail

#     PROJECT_SLUG="${CI_PROJECT_PATH_SLUG:-${CI_PROJECT_NAME:-project}}"
#     TARGET_PATH="${WIKI_PATH:-security/${PROJECT_SLUG}/latest}"
#     MD_RAW="$(cat out/security-report.md)"
#     TAGS_JSON=$(printf '%s' "${WIKI_TAGS:-}" | jq -Rs 'split(",") | map(gsub("^[[:space:]]+|[[:space:]]+$";"")) | map(select(length>0))')

#     call_gql () {
#       curl -sS -H "Authorization: Bearer ${WIKI_TOKEN}" -H "Content-Type: application/json"         --data "$1" "${WIKI_URL%/}/graphql"
#     }

#     # Lookup page by path
#     GET=$(jq -cn --arg path "$TARGET_PATH" --arg locale "$WIKI_LOCALE"       '{query:"query($path:String!,$locale:String!){ pages { singleByPath(path:$path, locale:$locale){ id } } }",
#         variables:{path:$path, locale:$locale}}')
#     RES=$(call_gql "$GET"); ID=$(echo "$RES" | jq -r '.data.pages.singleByPath.id // empty')

#     if [ -n "$ID" ]; then
#       # Update existing page with RAW markdown
#       UP=$(jq -cn --argjson id "$ID" --arg content "$MD_RAW"         '{query:"mutation($id:Int!,$content:String!){ pages { update(id:$id, content:$content){ responseResult{ succeeded message } } } }",
#           variables:{id:$id, content:$content}}')
#       call_gql "$UP" >/dev/null || true  # do not fail pipeline on update quirks
#     else
#       # Create new page with RAW markdown
#       CR=$(jq -cn         --arg path "$TARGET_PATH" --arg title "${WIKI_TITLE}" --arg locale "$WIKI_LOCALE"         --arg desc "${WIKI_DESCRIPTION}" --arg content "$MD_RAW" --argjson tags "$TAGS_JSON"         '{query:"mutation($path:String!,$title:String!,$locale:String!,$description:String!,$tags:[String]!, $content:String!){ pages { create(path:$path, title:$title, locale:$locale, editor:"markdown", isPublished:true, isPrivate:false, description:$description, tags:$tags, content:$content){ responseResult{ succeeded message } page{ id path } } } }",
#           variables:{path:$path, title:$title, locale:$locale, description:$desc, tags:$tags, content:$content}}')
#       call_gql "$CR" >/dev/null
#     fi
#   rules:
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
#       when: on_success
#     - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#       when: on_success
#     - if: $CI_PIPELINE_SOURCE == "schedule"
#       when: on_success
#     - when: never